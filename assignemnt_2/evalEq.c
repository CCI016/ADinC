// This program solves the equation of degree 1
// Student_1: Cainarean Constantin S4142152 C.Cainarean@student.rug.nl
// Student_2: Denis Garabajiu S4142551 D.Garabajiu@student.rug.nl

/*
 *
 * In this file an evaluator evaluateExpressions is definined that can evaluate
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <equation>   ::= <expression> '='  <expression>
 *
 * <expression> ::= [ ‘–’ ] ⟨term⟩ { ‘+’ ⟨term⟩ | ‘–’ ⟨term⟩ }
 *
 * <term>       ::= ⟨nat⟩ | [ ⟨nat⟩ ] ⟨identifier⟩ [ ‘^’ ⟨nat⟩ ]
 *
 * 
 * 
 *  * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 * 
 * 
 * 
 * 
 * Input for the evaluator is the token list constructed by the scanner (in scanner.c).
 * For the evaluation of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and evaluation of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include "scanner.h"
#include "recognizeEq.h"
#include "evalEq.h"

/* The function valueNumber is an extension of acceptNumber: the second parameter
 * is a pointer. After successful execution it refers to the numerical value
 * of the token that is recognized as a number.
 */

int valueNumber(List *lp, double *wp) {
  if (*lp != NULL && (*lp)->tt == Number) {
    *wp = ((*lp)->t).number;
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The functions valueFactor, valueTerm and valueExpression are extensions of
 * acceptFactor, acceptTerm en acceptExpression. The second parameter
 * is a pointer: after successful execution it refers to the value
 * of the initial segment of the token list that is recognized as a factor, term
 * or expression, respectively.
 */

int valueTerm(List *lp, double *wp, double *coef, int *flag) {
	List li;
	double i = 0.0;
	li = (*lp)->next;
	if (!acceptTerm(lp))
		return 0;
	if ((li->tt) == Identifier) {
		if (!valueNumber(lp, &i))
			*coef = 1;
			*flag = 0;
	} else {
		*coef = i;
		*flag = 1;
		return (valueNumber(lp,wp));
	}
	return 1;
}


int valueExpression(List *lp, double *wp, double *coef) { //<expression> ::= [ ‘–’ ] ⟨term⟩ { ‘+’ ⟨term⟩ | ‘–’ ⟨term⟩ }
  double w, coeff = 0;
  int i, flag = 0;
  i = (-1) * acceptCharacter(lp, '-');
	if (i == 0) 
		i = 1;
  if (!acceptTerm(lp)) {
    return 0;
  }
  w = *wp;
	coeff = *coef;
    while (*lp != NULL) {
      if (acceptCharacter(lp,'+')) {
        if (valueTerm(lp, &wp, &coef, &flag)) {
					if (!flag) {
						coeff += i * (*coef);
						i = 1;
					} else {
						w += i * (*wp);
						i = 1;
					}
        } else {
        return 0;
      }
    } else if (acceptCharacter(lp, '-')) {
      if (valueTerm(lp, &wp, &coef, &flag)) {
        if (!flag) {
						coeff -= i * (*coef);
						i = 1;
					} else {
						w -= i * (*wp);
						i = 1;
					}
      } else {
        return 0;
      }
    }
  }
	*coef = coeff;
  *wp = w;
  return 1;
}


int valueEquation (List *lp, double *sol) { //equation>   ::= <expression> '='  <expression>
  int leftCoef = 0, rightCoef = 0, leftValue = 0, rightValue = 0;
	if (!valueExpression(lp, &leftValue, &leftCoef) && !acceptCharacter(lp, '=')) {
    return 0;
  }
	if (!valueExpression (lp, &rightCoef, &rightValue)) {
		return 0;
	}
	leftCoef -= rightCoef;
	rightValue -= leftValue;
	*sol = rightValue / leftCoef;
	return 1;
}

/* The function evaluateExpressions performs a dialogue with the user, which
 * demonstrates the recognizer and the evaluator.
 */

void evaluateExpressions() {
  char *ar;
  List tl, tl1;
  double w = 0;
  printf("give an equation: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printList(tl);
    tl1 = tl;
    if ((findDegree(tl) == 1) && !varNum(tl) && valueEquation(&tl1, &w) && tl1 == NULL) {
      /* there may be no tokens left */
      printf("this is an equation in 1 variable of degree 1\nSolution %g\n", w);
    } else {
      tl1 = tl;
      if (acceptExpression(&tl1) && tl1 == NULL && !varNum(tl)) {
        printf("this is an equation in 1 variable of degree %d\n", findDegree(tl));
      } else if (acceptExpression(&tl1) && tl1 == NULL && (varNum(tl) == 1)){
        printf("this is an equation, but not in 1 variable\n");
      } else {
				printf("this is not an equation\n");
			}
    }
    free(ar);
    freeTokenList(tl);
    printf("\ngive an expression: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}
